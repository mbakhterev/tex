\usepackage{iftex}
\usepackage{amsmath}
\usepackage{xparse}

% Различные простые макросы без возни с низкоуровневым TeX

\newcommand\grk[1]{\foreignlanguage{greek}{#1}}
\newcommand\eng[1]{\foreignlanguage{english}{#1}}

\newcommand\range[2]{\enum{{#1} {\ldots} {#2}}}

\newif\ifclassic
\classicfalse

\newcommand\identity[1]{#1}
\newcommand\esc[1]{#1}

% ДВИЖОК ПОДСТАНОВКИ. Этот набор макросов нужен для вставки различных
% конструкций между и вокруг элементами списка атомов (кажется, в терминологии
% TeX они называются токенами), разделённых пробелами. Например:
%
%   \simpleinset{\times}{\identity}{a bc de g}
%
% должно раскрываться в: \ensuremath{a \times bc \times de \times g}

\makeatletter

\def\im@end{\relax}
\def\insetmap#1{\im@loop#1 \im@end\relax}

% Здесь \begingroup и \endgroup использованы для ограничения области видимости
% определения \im@next

\def\im@loop#1 #2\relax{%
  \begingroup
  \ifx \im@end#2
    \def\im@next{\endgroup\mapitem{#1}\relax}
  \else%
    \def\im@next{\endgroup\mapitem{#1}\relax\expandafter\inset\im@loop#2\relax}%
  \fi
  \im@next
}

\def\headsplitmap#1{\hs@split#1 \im@end\relax}

\def\hs@split#1 #2\relax{%
  \ifx \im@end#2%
    \maphead{#1}{\pretail\posttail}%
  \else
    \maphead{#1}{\pretail\insetmap{#2}\posttail}}

\def\get@first#1#2\relax{#1}

\makeatother

\newcommand\simpleinset[3]{%
  \begingroup%
  \def\inset{#1}%
  \def\mapitem{#2}%
  \ensuremath{\insetmap{#3}}%
  \endgroup}

\newcommand\nomapinset[2]{\simpleinset{#1}{\identity}{#2}}

% ДВИЖОК ПОДСТАНОВКИ. КОНЕЦ

% СХЕМЫ. Схемами названы генераторы новых команд по некоторым схемам. Очень
% много схожего между, например, \product и \unite: ассоциативные операторы,
% цепочки применений которых отличаются только лишь знаком, между элементами.
% Поэтому такие определения выделены в схемы.
%
% В предыдущем варианте схемы генерировали команды с переменным количеством
% аргументов при помощи \NewDocumentCommand. Это экономит идетификаторы команды,
% но довольно часто требует завершать обращения к командам \relax-ами. Что
% представляется неудобным. Кроме того, ощутимо (на слабых процессорах)
% увеличивается время компиляции. Поэтому текущая версия схем предлагает
% генерацию простых команд при помощи \newcommand. Формируемые команды
% различаются суффиксами.
%
%   i -- некоторый Identifier. Команда без аргументов, выдающая обозначение
%   операции. Для функций, например, это имя функции. 
%
%   x -- простое eXpression. Команда с одним аргументом (который может быть
%   списком, разделённых пробелом элементов, формирующая простое
%   выражение. \sumx{1 2 3} → 1 + 2 + 3.
%
%   r -- Range-выражения. Команда с двумя параметрами, которая должна изобразить
%   запись с троеточкой. \sumr{1}{10} = 1 + ... + 10.
%
%   e -- выражение с Enumeration. Очень часто индексы перечисления должны
%   пробегать от 1 до n, поэтому у команды 3 параметра: основа, имя индекса и
%   имя верхней границы. \sume{x}{i}{n} → \sum_{i=1}^{n}{x_i}.
%
%   f -- выражение From. Тоже перечисление, но с указанным нижним индексом.
%   Параметра, поэтому 4.
%
% Дополнительный суффикс m (mx, me, mf) означает команду, которая, первым
% аргументом берёт некий макрос, в который подставляется индекс или
% перечисляемые аргументы (будем говорить, что макрос применяется поэлементно):
%
%   \newcommand\spi[1]{{sp}_{#1}}\summx{a b c} → sp_a + sp_b + sp_c
%
% Необходимости в большем разнообразии суффиксов пока нет.
%
% Сами схемы могут быть в двух вариантах: простые и с декорациями (префикс d в
% названии схемы). Схемы с декорациями принимают дополнительные параметры:
% поэлементная декорация, декорация для простых выражения и для «больших»
% выражений (для \sum, например, нужны большие скобки). Декорации -- это команды
% с одним аргументом.
%
% Версии m команд с декорациями ожидают макроса для поэлементной обработки,
% который принимает два аргумента: декорацию (первый) и элемент (второй
% аргумент).
%
% Больше о схемах сказать нечего.

% Схемы для различных ассоциативных операторов с «большими» обозначениями (\sum,
% \bigcup и тому подобных). Примеры использования:
%
%   \opscheme{prod}{\times}{\prod}
%   \prodx{1 2 3} → 1 \times 2 \times 3
%
%   \newcommand\pars[1]{(#1)}
%   \dopscheme{sum}{+}{\sum}{\identity}{\pars}{\identity}
%   \sumx{1 2 3} → (1 + 2 + 3)

% Расстановка индексов для больших операторов (\prod, etc).

\newcommand\bigop[5]{\ensuremath{#1_{{#3}={#4}}^{#5}{{#2}_{#3}}}}
\newcommand\bigopm[5]{\ensuremath{#1_{{#3}={#4}}^{#5}{#2{#3}}}}

% #1 -- основа для имён команд
% #2 -- символ операции
% #3 -- «большой» групповой символ операции
\newcommand\opscheme[3]{%
  \expandafter\newcommand\csname#1i\endcsname[0]{\ensuremath{#2}}

  \expandafter\newcommand\csname#1x\endcsname[1]{\nomapinset{#2}{##1}}

  \expandafter\newcommand\csname#1r\endcsname[2]{%
    \nomapinset{#2}{{##1} {\dots} {##2}}}

  \expandafter\newcommand\csname#1e\endcsname[3]{%
    \csname#1f\endcsname{##1}{##2}{1}{##3}}

  \expandafter\newcommand\csname#1f\endcsname[4]{%
    \bigop{#3}{##1}{##2}{##3}{##4}}

  \expandafter\newcommand\csname#1mx\endcsname[2]{%
    \simpleinset{#2}{##1}{##2}}

  \expandafter\newcommand\csname#1mr\endcsname[3]{%
    \nomapinset{#2}{{##1{##2}} {\dots} {##1{##3}}}}

  \expandafter\newcommand\csname#1me\endcsname[3]{%
    \csname#1mf\endcsname{##1}{##2}{1}{##3}}

  \expandafter\newcommand\csname#1mf\endcsname[4]{%
    \bigopm{#3}{##1}{##2}{##3}{##4}}
}

% #1 -- основа для имён команд
% #2 -- символ операции
% #3 -- «большой» групповой символ операции
% #4 -- поэлементная декорация
% #5 -- декорация для простых формул
% #6 -- декорация для «больших» формул
\newcommand\dopscheme[6]{%
  \expandafter\newcommand\csname#1i\endcsname[0]{\ensuremath{#2}}

  \expandafter\newcommand\csname#1x\endcsname[1]{%
    #5{\simpleinset{#2}{#4}{##1}}}

  \expandafter\newcommand\csname#1r\endcsname[2]{%
    #5{\nomapinset{#2}{{#4{##1}} {\dots} {#4{##2}}}}}

  \expandafter\newcommand\csname#1e\endcsname[3]{%
    \csname#1f\endcsname{##1}{##2}{1}{##3}}

  \expandafter\newcommand\csname#1f\endcsname[4]{%
    #6{\bigop{#3}{#4{##1}}{##2}{##3}{##4}}}

  \expandafter\newcommand\csname#1mr\endcsname[3]{%
    #5{\nomapinset{#2}{{##1{#4}{##2}} {\dots} {##1{#4}{##3}}}}}

  \expandafter\newcommand\csname#1me\endcsname[3]{%
    \csname#1mf\endcsname{##1}{##2}{1}{##3}}

  \expandafter\newcommand\csname#1mx\endcsname[2]{%
    \begingroup%
    \newcommand\mdeco[1]{##1{#4}{####1}}%
    #5{\simpleinset{#2}{\mdeco}{##2}}%
    \endgroup}

  \expandafter\newcommand\csname#1mf\endcsname[4]{%
    \begingroup%
    \newcommand\mdeco[1]{##1{#4}{####1}}%
    #6{\bigopm{#3}{\mdeco}{##2}{##3}{##4}}%
    \endgroup}
}

% % \dots не должны попасть под украшение для элементов (пераметр 4). Поэтому
% % отдельная обработка
% \newcommand\dopscheme[6]{%
%   \NewDocumentCommand#1{mggg}{%
%     \IfNoValueTF{##4}
%       {\IfNoValueTF{##3}
%         {\IfNoValueTF{##2}
%           {\ensuremath{#5{\simpleinset{#3}{#4}{##1}}}}
%           {\ensuremath{#5{\nomapinset{#3}{{#4{##1}} {\dots} {#4{##2}}}}}}}
%         {#1{##1}{##2}{1}{##3}}}
%     {\ensuremath{{#6{\bigop{#2}{#4{##1}}{##2}{##3}{##4}}}}}}}

\newcommand\mopscheme[3]{%
  \NewDocumentCommand#1{mmgg}{%
    \IfNoValueTF{##4}
      {\IfNoValueTF{##3}
        {\simpleinset{#3}{##1}{##2}}
        {#1{##1}{##2}{1}{##3}}}
    {\mbigop{#2}{##1}{##2}{##3}{##4}}}}

\newcommand\dmopscheme[5]{%
  \NewDocumentCommand#1{mmgg}{%
    \IfNoValueTF{##4}
      {\IfNoValueTF{##3}
        \ensuremath{{#4{\simpleinset{#3}{##1}{##2}}}}
        {#1{##1}{##2}{1}{##3}}}
    {\ensuremath{#5{\mbigop{#2}{##1}{##2}{##3}{##4}}}}}}

% Схема с индексами

\newcommand\idxscheme[2]{\newcommand#1[1]{\ensuremath{{#2}_{##1}}}}

% Нечто вроде
%
%   \newcommand\midxscheme[2]{\newcommand#1[1]{\ensuremath{#2{##1}}}}
%
% здесь бессмысленно.

% Схемы перечислений: множества, последовательности. Используются примерно так:
%
%   \denumscheme{\easet}{,}{\atom}{\set}
%
% 3-й параметра -- поэлементный декоратор; 4-й -- декоратор всего выражения.

\newcommand\Enum[4]{\ensuremath{{#1}_{{#2}={#3}}^{#4}}}
\newcommand\mEnum[4]{\ensuremath{{#1{#2}}_{{#2}={#3}}^{#4}}}

\newcommand\enumscheme[2]{%
  \NewDocumentCommand#1{mggg}{%
    \IfNoValueTF{##4}
      {\IfNoValueTF{##3}
        {\IfNoValueTF{##2}
          {\nomapinset{#2}{##1}}
          {#1{{##1} {\dots} {##2}}}}
        {#1{##1}{##2}{1}{##3}}}
      {\Enum{##1}{##2}{##3}{##4}}}}

\newcommand\denumscheme[4]{%
  \NewDocumentCommand#1{mggg}{%
    \IfNoValueTF{##4}
      {\IfNoValueTF{##3}
        {\IfNoValueTF{##2}
          {\ensuremath{#4{\simpleinset{#2}{#3}{##1}}}}
          {\ensuremath{#4{\nomapinset{#2}{{#3{##1}} {\ldots} {#3{##2}}}}}}}
        {#1{##1}{##2}{1}{##3}}}
    {\ensuremath{#4{\Enum{##1}{##2}{##3}{##4}}}}}}

\newcommand\menumscheme[2]{%
  \NewDocumentCommand#1{mmgg}{%
    \IfNoValueTF{##4}
      {\IfNoValueTF{##3}
        {\simpleinset{#2}{##1}{##2}}
        {#1{##1}{##2}{1}{##3}}}
      {\mEnum{##1}{##2}{##3}{##4}}}}

\newcommand\dmenumscheme[3]{%
  \NewDocumentCommand#1{mmgg}{%
    \IfNoValueTF{##4}
      {\IfNoValueTF{##3}
        {\ensuremath{#3{\simpleinset{#2}{##1}{##2}}}}
        {#1{##1}{##2}{1}{##3}}}
    {\ensuremath{#3{\mEnum{##1}{##2}{##3}{##4}}}}}}

% Определение последовательности. Штука либо показывается заданным способом 2
% аргумент, либо показывается, как аппликация функции к указанному аргументу.

\newcommand\seqscheme[2]{%
  \NewDocumentCommand#1{g}{%
    \IfNoValueTF{##1}
      {\ensuremath{#2}}
      {\ifx\relax##1\relax{\ensuremath{#2}}\else{\app{#2}{##1}}\fi}}}

% Схемы для определения функций. Функциональный (f x y) и классический
% f(x,y) стили. Декорация подразумевается для изменения скобок

\newcommand\cappargs[1]{\nomapinset{,}{#1}}
\newcommand\appargs[1]{\nomapinset{\ }{#1}}

\newcommand\capp[2]{\ensuremath{{#1}\pars{\cappargs{#2}}}}
\newcommand\dcapp[3]{\ensuremath{{#1}{#3{\cappargs{#2}}}}}

\newcommand\app[2]{\pars{{#1}\ \appargs{#2}}}
\newcommand\dapp[3]{\ensuremath{#3{{#1}\ \appargs{#2}}}}

\newcommand\cfnscheme[2]{%
  \NewDocumentCommand#1{g}{%
    \IfNoValueTF{##1}
      {\ensuremath{#2}}
      {\ifx\relax##1\relax{\ensuremath{#2}}\else{\capp{#2}{##1}}\fi}}}

\newcommand\dcfnscheme[3]{%
  \NewDocumentCommand#1{g}{%
    \IfNoValueTF{##1}
      {\ensuremath{#2}}
      {\ifx\relax##1\relax{\ensuremath{#2}}\else{\dcapp{#2}{##1}{#3}}\fi}}}

\ifclassic
  \newcommand\fnscheme[2]{%
    \NewDocumentCommand#1{g}{%
      \IfNoValueTF{##1}
        {\ensuremath{#2}}
        {\ifx\relax##1\relax{\ensuremath{#2}}\else{\capp{#2}{##1}}\fi}}}

  \newcommand\dfnscheme[3]{%
    \NewDocumentCommand#1{g}{%
      \IfNoValueTF{##1}
        {\ensuremath{#2}}
        {\ifx\relax##1\relax{\ensuremath{#2}}\else{\dcapp{#2}{##1}{#3}}\fi}}}
\else
  \newcommand\fnscheme[2]{%
    \NewDocumentCommand#1{g}{%
      \IfNoValueTF{##1}
        {\ensuremath{#2}}
        {\ifx\relax##1\relax{\ensuremath{#2}}\else{\app{#2}{##1}}\fi}}}

  \newcommand\dfnscheme[3]{%
    \NewDocumentCommand#1{g}{%
      \IfNoValueTF{##1}
        {\ensuremath{#2}}
        {\ifx\relax##1\relax{\ensuremath{#2}}\else{\dapp{#2}{##1}{#3}}\fi}}}
\fi

% СХЕМЫ. КОНЕЦ

% Различные скобки

\newcommand\pars[1]{\ensuremath{(#1)}}
\newcommand\Pars[1]{\ensuremath{\left(#1\right)}}

\newcommand\brkt[1]{\ensuremath{[#1]}}
\newcommand\Brkt[1]{\ensuremath{\left[#1\right]}}

\newcommand\bras[1]{\ensuremath{\{#1\}}}
\newcommand\Bras[1]{\ensuremath{\left\{#1\right\}}}

\newcommand\spars[1]{\ensuremath{\atom{(}{#1}\atom{)}}}

% Домены

\makeatletter

\newcommand\domitem[1]{%
  \ifx\relax#1\relax
    {}
  \else\expandafter\ifx\get@first#1\relax\esc
    {#1}
  \else\expandafter\ifx\get@first#1\relax\Dom
    {#1}
  \else\expandafter\ifx\get@first#1\relax\DNm
    {#1}
  \else\expandafter\ifx\get@first#1\relax\KStar
    {#1}
  \else\expandafter\ifx\get@first#1\relax\KPlus
    {#1}
  \else\expandafter\ifx\get@first#1\relax\DProd
    {#1}
  \else\expandafter\ifx\get@first#1\relax\DSum
    {#1}
  \else\expandafter\ifx\get@first#1\relax\DSet
    {#1}
  \else
    \mathrm{#1}
  \fi\fi\fi\fi\fi\fi\fi\fi\fi}

\makeatother

% Стиль имён доменов

\newcommand\DNm[1]{\ensuremath{\domitem{#1}}}

\newcommand\Dom[1]{\ensuremath{{#1}_\bot}}

\newcommand\DBot[1]{\ensuremath{\bot_{\DNm{#1}}}}

\newcommand\DABot[1]{\ensuremath{\bot_{\atom{#1}}}}

% Скобки для доменных выражений

\newcommand\dset[1]{\Dom{\set{#1}}}
\newcommand\DSet[1]{\Dom{\Bras{#1}}}

\newcommand\dpars[1]{\Dom{\pars{#1}}}
\newcommand\DPars[1]{\Dom{\Pars{#1}}}

% Звёздочка Клини для переменных и доменов

\newcommand\kstar[1]{\ensuremath{{#1}^*}}
\newcommand\kplus[1]{\ensuremath{{#1}^+}}
\newcommand\KStar[1]{\kstar{\Dom{#1}}}
\newcommand\KPlus[1]{\kplus{\Dom{#1}}}

\dopscheme{DProd}{\times}{\prod}{\DNm}{\identity}{\identity}
\dopscheme{DSum}{+}{\sum}{\DNm}{\dpars}{\DPars}

% Произведения доменов

% \opscheme{\product}{\prod}{\times}
% \mopscheme{\mproduct}{\prod}{\times}

\opscheme{prod}{\times}{\prod}

\newcommand\prj[2]{\ensuremath{\pi^{#1}_{\enum{#2}}}}

% Суммы доменов

\dopscheme{oneof}{\sum}{+}{\identity}{\pars}{\Pars}
\dmopscheme{\moneof}{\sum}{+}{\pars}{\Pars}

\newcommand\inj[2]{\ensuremath{\epsilon^{#1}_{\enum{#2}}}}

% Последовательности и множества

\enumscheme{\cenum}{,}

\ifclassic
  \enumscheme{\enum}{,}
\else
  \enumscheme{\enum}{\ }
\fi

\NewDocumentCommand\seqcore{mggg}{%
  \IfNoValueTF{#3}
    {\nomapinset{\ }{#1}}
    {\IfNoValueTF{#4}
      {\seqcore{#1}{#2}{1}{#4}}
      {\ensuremath{{#1}_{{#2}={#3}}^{#4}}}}}

\NewDocumentCommand\mseqcore{mmgg}{%
  \IfNoValueTF{#3}
    {\simpleinset{\ }{#1}{#2}}
    {\IfNoValueTF{#4}
      {\mseqcore{#1}{#2}{1}{#3}}
      {\ensuremath{{#1{#2}}_{{#2}={#3}}^{#4}}}}}

\newcommand\tuple[1]{\ensuremath{[\enum{#1}]}}
\newcommand\Tuple[1]{\ensuremath{\left[\enum{#1}\right]}}


\NewDocumentCommand\tailinj{mmg}{%
  \IfNoValueTF{#3}
    {\ensuremath{#1\rightarrowtail#2}}
    {\ensuremath{\tailinj{#1}{#2}\ {#3}}}}

% Λ-абстракции

\newcommand\fndom[1]{%
  \begingroup%
  \def\inset{\to}%
  \def\mapitem{\identity}%
  \ensuremath{\insetmap{#1}}%
  \endgroup}

\newcommand\lam[1]{\ensuremath{\lambda#1\ldotp}}

% \newcommand{\capp}[1]{%
%   \begingroup%
%   \def\inset{,}%
%   \def\mapitem{\identity}%
%   \def\maphead{\identity}%
%   \def\pretail{(}%
%   \def\posttail{)}%
%   \ensuremath{\headsplitmap{#1}}%
%   \endgroup}
% 
% \ifclassic
%   \newcommand\app[1]{\capp{#1}}
%   \newcommand\papp[1]{\capp{#1}}
% \else
%   \newcommand{\app}[1]{%
%     \begingroup%
%     \def\inset{\,}%
%     \def\mapitem{\identity}%
%     \ensuremath{\insetmap{#1}}%
%     \endgroup}
% 
%   \newcommand{\papp}[1]{\ensuremath{(\app{#1})}}
% \fi

% S-выражения

\makeatletter

\newcommand\codeitem[1]{%
  \ifx\relax#1\relax
    \text{\texttt{ }}
  \else\expandafter\ifx\get@first#1\relax\esc
    {#1}
  \else\expandafter\ifx\get@first#1\relax\sexp
    {#1}
  \else\expandafter\ifx\get@first#1\relax\satom
    {#1}
  \else
    \text{\texttt{#1}}
 \fi\fi\fi\fi}

\makeatother

\newcommand\baresexp[1]{%
  \begingroup%
  \def\inset{\text{\texttt{\ }}}%
  \def\mapitem{\codeitem}%
  \ensuremath{\insetmap{#1}}%
  \endgroup}

\newcommand\sexp[1]{\ensuremath{\text{\texttt{(}}\baresexp{#1}\text{\texttt{)}}}}

\newcommand\atom[1]{\ensuremath{\text{\texttt{#1}}}}
\newcommand\satom[1]{\ensuremath{\text{\texttt{#1}}}}

\newcommand\fn[1]{\app{#1}}

\newcommand\clam[0]{\ensuremath{\text{\texttt{λ}}}}
\newcommand\fapp[1]{\sexp{#1}}
\newcommand\fabs[2]{\sexp{\clam{} {#1} #2}}

% CSP

% \newcommand\procop[0]{\ensuremath{\twoheadrightarrow}}

% \newcommand\proc[1]{%
%   \begingroup%
%   \def\inset{\procop}%
%   \def\mapitem{\identity}%
%   \ensuremath{\insetmap{#1}}%
%   \endgroup}

\newcommand\pc[1]{\proc{#1}}

\newcommand\pevtone[1]{\ensuremath{\text{\texttt{#1}}}}

\NewDocumentCommand\pevt{mg}{%
  \IfNoValueTF{#2}
    {\pevtone{#1}}
    {\ensuremath{{\pevtone{#1}{:}{#2}}}}}

\newcommand\pparop{\ensuremath{\parallel}}
\newcommand\ppar[1]{%
  \begingroup%
  \def\inset{\pparop}%
  \def\mapitem{\identity}%
  \ensuremath{\insetmap{#1}}%
  \endgroup}

\newcommand{\pord}[1]{\inscribe{\sqsubseteq}{#1}}
\newcommand{\psel}[1]{\inscribe{\mid}{#1}}
\newcommand{\pmurec}[1]{\mu{#1}\ldotp\ }

\newcommand{\tr}[1]{\seq{#1}}

% \newcommand{\palpha}[1]{{\mbox{\texttt{α}}{#1}}}
% \newcommand{\tproc}[1]{{\mbox{\texttt{ι}}{#1}}}

\newcommand{\palpha}[1]{\text{\textgreek{α}}#1}
\newcommand{\tproc}[1]{\text{\textgreek{ι}}#1}

\newcommand{\tcat}[1]{\sqcat{#1}}

\newcommand{\tord}[1]{\inscribe{\le}{#1}}

\newcommand{\PC}[1]{\tuple{{\palpha{#1}} {\tproc{#1}}}}

\newcommand\sqcat[1]{%
  \begingroup%
  \def\inset{\cdot}%
  \def\mapitem{\identity}%
  \ensuremath{\insetmap{#1}}%
  \endgroup}

% \newcommand\seq[1]{\tuple{#1}}

% \newcommand\term[1]{\fn{TERM {\unite{#1}}}}

% \newcommand\term[1]{\fn{TERM #1}}
% \newcommand\tval[1]{\fn{val #1}}

\makeatletter

\def\extract@code#1#2\relax{#1}

\newcommand\code[1]{\relax%
  \expandafter\ifx\extract@code#1\relax\identity%
    {#1}%
  \else%
    \mbox{\texttt{#1}}%
  \fi\relax}

\makeatother

\newcommand\bbind[2]{\ensuremath{{#1}/{#2}}}
\newcommand\bind[2]{\ensuremath{[\bbind{#1}{#2}]}}
\newcommand\bindc[2]{\tuple{\bind{\code{#1}}{\code{#2}}}}

\newcommand\codespace[0]{\mbox{\texttt{ }}}

\newcommand{\bred}[1]{\inscribe{\mathrel{{\to}_\beta}}{#1}}
\newcommand{\aeq}[1]{\inscribe{\mathrel{{=}_\alpha}}{#1}}

% \newcommand{\tuple}[1]{\seq{#1}}
% \newcommand\tlen[1]{\card{\dom{#1}}}
% \newcommand\tlen[1]{{#1_{\#}}}
\newcommand\tend[1]{{#1}_{\tlen{#1}-1}}

% \newcommand\tlen[1]{\capp{\mathrm{len} {#1}}}

%  \begingroup\def\inset{\times} \def\doword{} {\words#1}\endgroup}

\newcommand{\rel}[2]{\inscribe{\mathrel{#1}}{#2}}
\newcommand{\relation}[2]{\rel{#1}{#2}}

\newcommand{\card}[1]{\left|#1\right|}

\newcommand{\forevery}[1]{\forall{#1}\ldotp\ }
\newcommand{\thereis}[1]{\exists{#1}\ldotp\ }
% \newcommand{\lam}[1]{\text{\textgreek{λ}}#1\ldotp}

\newcommand{\coll}[2]{\left\{{{#1} \mid {#2}}\right\}}

\newcommand\nats{\mathbb{N}}

\newcommand{\bottom}[0]{{\bot}}
\newcommand{\dless}[0]{\sqsubseteq}
\newcommand{\dord}[1]{\inscribe{\dless}{#1}}
\newcommand{\dbot}[1]{{\bottom_{#1}}}

% \newcommand\all[1]{\inscribe{\wedge}{#1}}
% \newcommand\any[1]{\inscribe{\vee}{#1}}

\newcommand\all[1]{%
  \begingroup%
  \def\inset{\wedge}%
  \def\mapitem{\identity}%
  \ensuremath{\insetmap{#1}}%
  \endgroup}

\newcommand\any[1]{%
  \begingroup%
  \def\inset{\vee}%
  \def\mapitem{\identity}%
  \ensuremath{\insetmap{#1}}%
  \endgroup}

\newcommand\allop{\all{{} {}}}
\newcommand\anyop{\any{{} {}}}

% \newcommand{\join}[1]{\inscribe{\cap}{#1}}
% \newcommand{\unite}[1]{\inscribe{\cup}{#1}}

\newcommand\join[1]{%
  \begingroup%
  \def\inset{\cap}%
  \def\mapitem{\identity}%
  \ensuremath{\insetmap{#1}}%
  \endgroup}

\newcommand\unite[1]{%
  \begingroup%
  \def\inset{\cup}%
  \def\mapitem{\identity}%
  \ensuremath{\insetmap{#1}}%
  \endgroup}

\newcommand{\lub}[1]{\textstyle\bigsqcup{#1}}

\ifclassic
  \newcommand{\cpars}[1]{\left(#1\right)}
  \newcommand{\muset}[1]{\mu\left\{{#1}\right\}}
\else
  \newcommand{\cpars}[1]{#1}
  \newcommand{\muset}[1]{\mu{#1}}
\fi

\newcommand\fix[1]{{\mbox{fix}_{#1}\,}}
\newcommand\dom[1]{{\mbox{dom}\,{#1}}}


\newcommand\Nats{\nats}
% \newcommand\Nless[2]{{\all{{{#2} \in \Nats} {{#1} \le {#2}}}}}
% \newcommand\Nless[1]{{\nats_{{} < {#1}}}}

\newcommand\cpnmode[1]{\fn{mode #1}}
\newcommand\cpntype[1]{\fn{Type #1}}
\newcommand\cpnready[1]{\fn{ready #1}}

\newcommand\holesign{ 
  \mathchoice
    {\mbox{§}}
    {\mbox{§}}
    {\mbox{\scriptsize §}}
    {\mbox{\tiny §}}}

\newcommand\hole[1]{\holesign{#1}}

\newcommand\tlanext[1]{{{#1}'}}

\newcommand\tvar[1]{\fn{VAR #1}}
\newcommand\tlact[1]{\mathcal{#1}}
\newcommand\tlast[2]{\left[#1\right]_{#2}}
\newcommand\tlalways[1]{\square{#1}}

\newcommand\St{\mathbf{St}}

\newcommand\bydef{\overset{\mbox{\tiny def}}{=}}

\newcommand\iseq[3]{\tuple{#1}_{{#2}\in {#3}}}
\newcommand\nseq[2]{\iseq{#1}{#2}{\nats}}
\newcommand\bseq[4]{\iseq{\bind{#1_{#3}}{#2_{#3}}}{#3}{\Nless{#4}}}

\newcommand\R{\mathbf{R}}

\newcommand\tnothing{}
\newcommand\tsubst[1]{\left[#1\right]}
\newcommand\tval[1]{\splitinscribe\identity\identity\tsubst\tnothing#1\relax}

\newcommand\tlaval[1]{\splitinscribe\tlact\identity\tsubst\tnothing#1\relax}

\newcommand\upto[1]{\downarrow{#1}}
% \newcommand\uptoex[1]{\upto{({#1}-1)}}
% \newcommand\uptoex[1]{\text{\v{$\downarrow$}}{#1}}
\newcommand\uptoex[1]{{\hat{{\downarrow}}}{#1}}
% \newcommand\Nless[1]{\set{{\cdot}_{\Nats} < {#1}}}
\newcommand\Nless[1]{\uptoex{#1}}

\newcommand\stx[1]{\ensuremath{\text{#1}}}
\newcommand\bstx[1]{\ensuremath{{\text{#1}}_{\text{B}}}}

\newcommand\tcode[1]{\lstinline`#1`}
\newcommand\mcode[1]{\mbox{\tcode{#1}}}
\newcommand\mcsp{\mbox{\texttt{ }}}

\newcommand\codepair[2]{\(\frac{\mathrm{#1}}{\mathrm{#2}}\)}
% \newcommand\codepair[2]{\({\mathrm{#1}}_{\mathrm{#2}}\)}
% \newcommand\codepair[2]{{#1}/{#2}}

\newcommand\mpi[1]{\codepair{MPI}{#1}}
\newcommand\ride[1]{\codepair{RiDE}{#1}}
\newcommand\hadoop[1]{\codepair{Hadoop}{#1}}

\newcommand\uid[1]{\fn{{\text{\texttt{uid}}} {#1}}}
\newcommand\UID[1]{\fn{{\text{\texttt{UID}}} {#1}}}
\newcommand\node[1]{\fn{{\text{\texttt{node}}} {#1}}}

\newcommand\eval[1]{\llbracket {#1} \rrbracket}

\newenvironment{centercode}%
  {\begin{center}\begin{tabular}{c}}%
  {\end{tabular}\end{center}}

\newcommand\wa[1]{\ensuremath{{#1}_w}}

\newcommand\Input[1]{\fn{I {#1}}}
\newcommand\Wrte[1]{\fn{W {#1}}}
\newcommand\Img[1]{\text{Im}\,{#1}}

\providecommand\set[1]{\ensuremath{\{#1\}}}

\newcommand\In[1]{#1}
\newcommand\Wr[1]{#1}

% \newcommand\lx[1]{\grk{l}-#1}
\newcommand\lx[1]{\ensuremath{\lambda}-#1}
\newcommand\px[1]{\grk{p}-#1}

% \newcommand\im[1]{\capp{\mathrm{im} {#1}}}

\cfnscheme{\im}{\mathrm{im}}
